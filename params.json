{"name":"Fastpush","tagline":"Smart Incremental application update","body":"FastPush: Push updates to Cloud Foundry/Heroku apps in seconds\r\n==\r\n\r\n![FastPush an example nodejs application with Cloud Foundry](https://github.com/xiwenc/fastpush/raw/master/resources/fastpush-example-nodejs.gif)\r\n> Why should your development environment be any different from your production environment except for the number of instances?\r\n\r\n*FastPush* allows you to instantly push updates of your code to [Cloud Foundry](https://www.cloudfoundry.org)/[Heroku](https://www.heroku.com). If static files have changed, it just syncs those. If code has changed, it also restarts the app. As a result updating your application takes *seconds* instead of *minutes*. So no more getting coffee while waiting for `cf push` and more importantly, your *flow* won't be interrupted.\r\n\r\nPros:\r\n- Never install local database, message brokers, email providers etc., simply use the Free Tiers of the 3rd party providers on Heroku / Cloud Foundry\r\n- Eliminate differences between dev & prod, no more `port = (env.process.PORT || 5000)`\r\n\r\nCons:\r\n- Unable to work offline\r\n- App reverts to last pushed version when restarted\r\n- Still need full push when dependencies change\r\n\r\n\r\nHow does it work\r\n===\r\n\r\nWe add a small http proxy (`cf-fastpush-controller`, written in Go) between the app's http port and the PaaS routing layer. This http proxy just proxies everything to the application, except that it has a file synchronization api listening on `/_fastpush/`. This allows us to modify the live file system of the container.\r\n\r\nWe transfer local files to the server with the `cf-fastpush-plugin`, a cf cli plugin that talks to the controller. It tracks your local files and synchronizes those that have been changed or added.\r\n\r\nThe actual code does more than what is documented here. So we suggest you to read the source if you are really interested in how it works and what else it can do.\r\n\r\n> Current documentation is fairly low because this project is still very young. We invite others to contribute. The code quality is not great either and we plan to refactor it in the near future. Please keep in mind the current state is far from production ready but for its purpose it is good enough to be used as a developer tool ;)\r\n\r\nRelated projects\r\n===\r\n\r\n- [fastpush](https://github.com/xiwenc/fastpush) (this repo) FastPush documentation with integration examples\r\n- [cf-fastpush-controller](https://github.com/xiwenc/cf-fastpush-controller) FastPush server written in Go that can be included in your application root directory\r\n- [cf-fastpush-plugin](https://github.com/xiwenc/cf-fastpush-plugin) FastPush client plugin for Cloud Foundry CLI\r\n\r\nDisclaimer\r\n===\r\n\r\n- FastPush is lightning fast because it skips the `staging` phase in Cloud Foundry for subsequent changes. This means that `cf fast-push` cannot and will never replace the standard `cf push` command.\r\n- FastPush *does not* work with multi-instance deployments\r\n- FastPush should *never* be used to deploy production applications\r\n\r\nUsage\r\n===\r\n\r\nIt is extremely easy to start using *FastPush*:\r\n\r\n1. Build and include [cf-fastpush-controller](https://github.com/xiwenc/cf-fastpush-controller) executable in your application code.\r\n2. Build and install [cf-fastpush-plugin](https://github.com/xiwenc/cf-fastpush-plugin) in your CF CLI. As of this writing there is no Heroku plugin yet.\r\n3. Modify your `manifest.yml` to configure your application and `cf-fastpush-controller`.\r\n4. After your first `cf push` you can incrementally push updates with `cf fast-push`.\r\n\r\nCloud Foundry Tutorial\r\n===\r\n\r\nFor those that are still confused why *FastPush* is such an awesome tool just follow this short step-by-step tutorial where we deploy an example application:\r\n\r\nInstall cf-fastpush-plugin:\r\n```\r\nwget https://github.com/xiwenc/cf-fastpush-plugin/raw/master/cf-fastpush-plugin\r\nchmod 755 cf-fastpush-plugin\r\ncf install-plugin cf-fastpush-plugin\r\nrm cf-fastpush-plugin\r\n```\r\n\r\nLet's prepare an example application. Here we choose python, but there are more examples:\r\n```\r\ngit clone https://github.com/xiwenc/fastpush.git\r\ncd fastpush/examples/python\r\n```\r\n\r\nInstall `cf-fastpush-controller` in our example application:\r\n```\r\nwget https://github.com/xiwenc/cf-fastpush-controller/raw/master/cf-fastpush-controller\r\nchmod +x cf-fastpush-controller\r\n```\r\n\r\nNext push our example application:\r\n```\r\ntime cf push samplefastpush\r\n# ... snip ...\r\n# #0   running   2016-01-29 09:31:06 PM   0.0%   15.7M of 128M   114.9M of 256M\r\n# ... snip ...\r\n#cf push samplefastpush  1.88s user 1.91s system 5% cpu 1:04.55 total\r\n```\r\n\r\nNow edit the source code a bit and re-push the app with `fast-push`:\r\n```\r\nvim hello.py\r\ntime cf fast-push samplefastpush\r\n# ... snip ...\r\n# [MOD] hello.py\r\n# [NEW] manifest.yml\r\n# Restarting after updating 2 files\r\n\r\n# cf fast-push samplefastpush  0.40s user 0.05s system 7% cpu 5.667 total\r\n```\r\nPlease note that the initial push is not very representative of a real world scenario because it adds overhead of having to push the cf-fastpush-controller binary. We can speed it up for slow connections by incorporating it in buildpacks that fetches the executable if needed.\r\n\r\nCredits:\r\n===\r\n- Mendix: Great place to work\r\n- Colleagues @ Mendix\r\n","google":"UA-74177616-1","note":"Don't delete this file! It's used internally to help with page regeneration."}